/**
 * @fileoverview Employee Service - Business logic for employee management
 *
 * This service handles all employee-related database operations:
 * - Create new employee with validation
 * - Retrieve employees with filters and pagination
 * - Update employee information
 * - Soft delete (deactivate) employees
 * - Email uniqueness checks
 *
 * Features:
 * - Auto-generated employee numbers (EMP-XXXXXX) via database trigger
 * - Role information joined via LEFT JOIN on roles table
 * - Search across multiple fields (name, email, employee_number)
 * - Active/inactive status filtering
 * - Pagination support for large datasets
 *
 * Database Tables:
 * - employees: Main employee records
 * - roles: Employee roles (joined for role_name)
 *
 * @module services/employee
 * @requires ../config/database - PostgreSQL connection pool
 * @requires ../types/employee.types - Employee type definitions
 * @author Claude Sonnet 4.5 <noreply@anthropic.com>
 * @created 2026-02-14 (Phase 4A: Employee Management)
 * @updated 2026-02-14 (Added comprehensive JSDoc documentation)
 */

import { pool } from '../config/database';
import {
  Employee,
  CreateEmployeeDTO,
  UpdateEmployeeDTO,
  EmployeeFilters,
  EmployeePagination,
  EmployeeListResult,
} from '../types/employee.types';

/**
 * Create a new employee
 *
 * Inserts a new employee record into the database. The employee_number is
 * auto-generated by the database trigger (EMP-000001, EMP-000002, etc.).
 * All fields except phone, assigned_terminal_id, and user_id are required.
 *
 * @async
 * @param {CreateEmployeeDTO} data - Employee data to create
 * @param {string} data.first_name - Employee's first name (1-100 chars)
 * @param {string} data.last_name - Employee's last name (1-100 chars)
 * @param {string} data.email - Employee's email address (must be unique)
 * @param {string} [data.phone] - Employee's phone number (optional)
 * @param {string} data.hire_date - Hire date in YYYY-MM-DD format
 * @param {number} data.role_id - Foreign key to roles table
 * @param {string} [data.assigned_terminal_id] - UUID of assigned POS terminal (optional)
 * @param {string} [data.user_id] - UUID of auth user account (optional)
 * @returns {Promise<Employee>} Created employee record with auto-generated employee_number
 * @throws {Error} If database insert fails or returns no rows
 *
 * @example
 * const employee = await createEmployee({
 *   first_name: 'John',
 *   last_name: 'Doe',
 *   email: 'john.doe@example.com',
 *   phone: '555-1234',
 *   hire_date: '2026-02-14',
 *   role_id: 2
 * });
 * console.log(employee.employee_number); // 'EMP-000001'
 */
export async function createEmployee(data: CreateEmployeeDTO): Promise<Employee> {
  const query = `
    INSERT INTO employees (
      first_name, last_name, email, phone, hire_date,
      role_id, assigned_terminal_id, user_id
    )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    RETURNING *
  `;

  const values = [
    data.first_name,
    data.last_name,
    data.email,
    data.phone || null,
    data.hire_date,
    data.role_id,
    data.assigned_terminal_id || null,
    data.user_id || null,
  ];

  const result = await pool.query(query, values);

  if (result.rowCount === null || result.rowCount === 0) {
    throw new Error('Failed to create employee');
  }

  return result.rows[0];
}

/**
 * Get employees with filters and pagination
 *
 * Retrieves a paginated list of employees from the database with optional
 * filtering by role, active status, and search term. Joins with roles table
 * to include role_name in results. Returns both employee data and pagination
 * metadata (total, page, limit, totalPages).
 *
 * Search term matches against:
 * - first_name (case-insensitive)
 * - last_name (case-insensitive)
 * - email (case-insensitive)
 * - employee_number (case-insensitive)
 *
 * @async
 * @param {EmployeeFilters} [filters={}] - Filter criteria
 * @param {number} [filters.role_id] - Filter by role ID
 * @param {boolean} [filters.is_active] - Filter by active status (true/false)
 * @param {string} [filters.search] - Search term for name, email, or employee number
 * @param {EmployeePagination} [pagination={}] - Pagination options
 * @param {number} [pagination.page=1] - Page number (1-indexed)
 * @param {number} [pagination.limit=10] - Items per page
 * @returns {Promise<EmployeeListResult>} Employee list with pagination metadata
 * @returns {Employee[]} return.employees - Array of employee records with role_name
 * @returns {number} return.total - Total number of matching employees
 * @returns {number} return.page - Current page number
 * @returns {number} return.limit - Items per page
 * @returns {number} return.totalPages - Total number of pages
 * @throws {Error} If database query fails
 *
 * @example
 * // Get first page of active employees
 * const result = await getEmployees(
 *   { is_active: true },
 *   { page: 1, limit: 20 }
 * );
 * console.log(`Found ${result.total} employees`);
 *
 * @example
 * // Search for employees by name
 * const result = await getEmployees({ search: 'john' });
 * result.employees.forEach(emp => console.log(emp.full_name));
 */
export async function getEmployees(
  filters: EmployeeFilters = {},
  pagination: EmployeePagination = {}
): Promise<EmployeeListResult> {
  const page = pagination.page || 1;
  const limit = pagination.limit || 10;
  const offset = (page - 1) * limit;

  // Build WHERE clause
  const conditions: string[] = [];
  const params: any[] = [];
  let paramIndex = 1;

  if (filters.role_id !== undefined) {
    conditions.push(`e.role_id = $${paramIndex}`);
    params.push(filters.role_id);
    paramIndex++;
  }

  if (filters.is_active !== undefined) {
    conditions.push(`e.is_active = $${paramIndex}`);
    params.push(filters.is_active);
    paramIndex++;
  }

  if (filters.search) {
    conditions.push(`(
      e.first_name ILIKE $${paramIndex} OR
      e.last_name ILIKE $${paramIndex} OR
      e.email ILIKE $${paramIndex} OR
      e.employee_number ILIKE $${paramIndex}
    )`);
    params.push(`%${filters.search}%`);
    paramIndex++;
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  // Get employees
  const query = `
    SELECT
      e.*,
      r.role_name
    FROM employees e
    LEFT JOIN roles r ON e.role_id = r.id
    ${whereClause}
    ORDER BY e.created_at DESC
    LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
  `;

  params.push(limit, offset);
  const result = await pool.query(query, params);

  // Get total count
  const countQuery = `
    SELECT COUNT(*) as count
    FROM employees e
    ${whereClause}
  `;

  const countResult = await pool.query(countQuery, params.slice(0, paramIndex - 1));
  const total = parseInt(countResult.rows[0].count, 10);
  const totalPages = Math.ceil(total / limit);

  return {
    employees: result.rows,
    total,
    page,
    limit,
    totalPages,
  };
}

/**
 * Get employee by ID
 *
 * Retrieves a single employee record by ID with role information joined.
 * Returns null if employee not found.
 *
 * @async
 * @param {number} id - Employee ID to retrieve
 * @returns {Promise<Employee | null>} Employee record with role_name, or null if not found
 * @throws {Error} If database query fails
 *
 * @example
 * const employee = await getEmployeeById(1);
 * if (employee) {
 *   console.log(`${employee.full_name} - ${employee.role_name}`);
 * }
 */
export async function getEmployeeById(id: number): Promise<Employee | null> {
  const query = `
    SELECT
      e.*,
      r.role_name
    FROM employees e
    LEFT JOIN roles r ON e.role_id = r.id
    WHERE e.id = $1
  `;

  const result = await pool.query(query, [id]);

  if (result.rowCount === 0) {
    return null;
  }

  return result.rows[0];
}

/**
 * Get employee by email
 *
 * Retrieves a single employee record by email address with role information joined.
 * Used for email uniqueness validation during create/update operations.
 * Returns null if employee not found.
 *
 * @async
 * @param {string} email - Employee email address to search for
 * @returns {Promise<Employee | null>} Employee record with role_name, or null if not found
 * @throws {Error} If database query fails
 *
 * @example
 * const existing = await getEmployeeByEmail('john@example.com');
 * if (existing) {
 *   console.log('Email already in use');
 * }
 */
export async function getEmployeeByEmail(email: string): Promise<Employee | null> {
  const query = `
    SELECT
      e.*,
      r.role_name
    FROM employees e
    LEFT JOIN roles r ON e.role_id = r.id
    WHERE e.email = $1
  `;

  const result = await pool.query(query, [email]);

  if (result.rowCount === 0) {
    return null;
  }

  return result.rows[0];
}

/**
 * Update employee
 *
 * Updates an existing employee record with partial data. Only provided fields
 * are updated; omitted fields remain unchanged. Automatically sets updated_at
 * timestamp. Returns null if employee not found.
 *
 * Note: This function only updates the database. Email uniqueness and role
 * existence validation should be performed by the controller before calling.
 *
 * @async
 * @param {number} id - Employee ID to update
 * @param {UpdateEmployeeDTO} data - Partial employee data to update
 * @param {string} [data.first_name] - New first name
 * @param {string} [data.last_name] - New last name
 * @param {string} [data.email] - New email address
 * @param {string} [data.phone] - New phone number
 * @param {number} [data.role_id] - New role ID
 * @param {string} [data.assigned_terminal_id] - New terminal ID
 * @param {string} [data.termination_date] - Termination date (YYYY-MM-DD)
 * @param {boolean} [data.is_active] - Active status
 * @returns {Promise<Employee | null>} Updated employee record, or null if not found
 * @throws {Error} If database query fails
 *
 * @example
 * const updated = await updateEmployee(1, {
 *   email: 'newemail@example.com',
 *   role_id: 3
 * });
 * if (updated) {
 *   console.log('Employee updated successfully');
 * }
 *
 * @example
 * // Terminate employee
 * await updateEmployee(5, {
 *   termination_date: '2026-02-14',
 *   is_active: false
 * });
 */
export async function updateEmployee(
  id: number,
  data: UpdateEmployeeDTO
): Promise<Employee | null> {
  const fields: string[] = [];
  const values: any[] = [];
  let paramIndex = 1;

  if (data.first_name !== undefined) {
    fields.push(`first_name = $${paramIndex}`);
    values.push(data.first_name);
    paramIndex++;
  }

  if (data.last_name !== undefined) {
    fields.push(`last_name = $${paramIndex}`);
    values.push(data.last_name);
    paramIndex++;
  }

  if (data.email !== undefined) {
    fields.push(`email = $${paramIndex}`);
    values.push(data.email);
    paramIndex++;
  }

  if (data.phone !== undefined) {
    fields.push(`phone = $${paramIndex}`);
    values.push(data.phone);
    paramIndex++;
  }

  if (data.role_id !== undefined) {
    fields.push(`role_id = $${paramIndex}`);
    values.push(data.role_id);
    paramIndex++;
  }

  if (data.assigned_terminal_id !== undefined) {
    fields.push(`assigned_terminal_id = $${paramIndex}`);
    values.push(data.assigned_terminal_id);
    paramIndex++;
  }

  if (data.termination_date !== undefined) {
    fields.push(`termination_date = $${paramIndex}`);
    values.push(data.termination_date);
    paramIndex++;
  }

  if (data.is_active !== undefined) {
    fields.push(`is_active = $${paramIndex}`);
    values.push(data.is_active);
    paramIndex++;
  }

  if (fields.length === 0) {
    // No fields to update
    return await getEmployeeById(id);
  }

  fields.push(`updated_at = CURRENT_TIMESTAMP`);
  values.push(id);

  const query = `
    UPDATE employees
    SET ${fields.join(', ')}
    WHERE id = $${paramIndex}
    RETURNING *
  `;

  const result = await pool.query(query, values);

  if (result.rowCount === 0) {
    return null;
  }

  return result.rows[0];
}

/**
 * Deactivate employee (soft delete)
 *
 * Sets is_active to false instead of deleting the employee record.
 * Preserves employee history for transactions and audit trail.
 * Returns null if employee not found.
 *
 * Note: Soft delete is preferred over hard delete to maintain referential
 * integrity with transactions and maintain historical records.
 *
 * @async
 * @param {number} id - Employee ID to deactivate
 * @returns {Promise<Employee | null>} Deactivated employee record, or null if not found
 * @throws {Error} If database query fails
 *
 * @example
 * const deactivated = await deactivateEmployee(1);
 * if (deactivated) {
 *   console.log(`Employee ${deactivated.employee_number} deactivated`);
 * }
 */
export async function deactivateEmployee(id: number): Promise<Employee | null> {
  const query = `
    UPDATE employees
    SET is_active = false, updated_at = CURRENT_TIMESTAMP
    WHERE id = $1
    RETURNING *
  `;

  const result = await pool.query(query, [id]);

  if (result.rowCount === 0) {
    return null;
  }

  return result.rows[0];
}

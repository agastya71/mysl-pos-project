/**
 * @fileoverview Categories Redux Slice - Manages hierarchical product categories
 *
 * This slice handles category management with tree structure support:
 * - Hierarchical category tree (parent-child relationships)
 * - Full CRUD operations (Create, Read, Update, Delete)
 * - Active/inactive filtering
 * - Selected category state for viewing/editing details
 *
 * Categories are stored as a tree structure where each category can have:
 * - Parent category (parent_category_id)
 * - Multiple child categories (children array)
 * - Display order for sorting
 * - Active status (soft delete)
 *
 * The backend builds the tree structure from flat database records using
 * a two-pass algorithm, so this slice receives and stores pre-built trees.
 *
 * @module store/slices/categories
 * @requires @reduxjs/toolkit - Redux state management with reducers and thunks
 * @author Claude Opus 4.6 <noreply@anthropic.com>
 * @created 2026-02-XX (Phase 3A)
 * @updated 2026-02-08 (Documentation)
 */

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { categoryApi } from '../../services/api/category.api';
import {
  CategoryWithChildren,
  CreateCategoryRequest,
  UpdateCategoryRequest,
} from '../../types/category.types';

/**
 * Categories state interface
 *
 * Manages category tree and selected category for editing.
 *
 * @interface CategoriesState
 * @property {CategoryWithChildren[]} categories - Category tree (root categories with nested children)
 * @property {CategoryWithChildren | null} selectedCategory - Currently viewed/edited category
 * @property {boolean} loading - True during async category operations
 * @property {string | null} error - Error message from failed operations
 */
interface CategoriesState {
  categories: CategoryWithChildren[];
  selectedCategory: CategoryWithChildren | null;
  loading: boolean;
  error: string | null;
}

// Initial empty state
const initialState: CategoriesState = {
  categories: [],
  selectedCategory: null,
  loading: false,
  error: null,
};

/**
 * Async thunk: Fetch all categories as tree structure
 *
 * Retrieves category tree from backend. Categories are returned as a
 * hierarchical structure with root categories containing nested children.
 *
 * The backend performs tree building using a two-pass O(n) algorithm:
 * - Pass 1: Create map of all categories with empty children arrays
 * - Pass 2: Link each category to its parent (or root if no parent)
 *
 * @async
 * @function fetchCategories
 * @param {boolean} [activeOnly] - If true, return only active categories (default: all)
 * @returns {Promise<CategoryWithChildren[]>} Array of root categories with nested children
 *
 * @example
 * // Fetch all categories (active and inactive)
 * dispatch(fetchCategories());
 *
 * @example
 * // Fetch only active categories
 * dispatch(fetchCategories(true));
 *
 * @see categoryApi.getCategories for backend API call
 * @see CategoryWithChildren interface in types/category.types.ts
 */
export const fetchCategories = createAsyncThunk(
  'categories/fetchCategories',
  async (activeOnly?: boolean) => {
    return await categoryApi.getCategories(activeOnly);
  }
);

/**
 * Async thunk: Fetch category details by ID
 *
 * Retrieves full category details including children. Used when editing
 * a category to populate the form with current values.
 *
 * @async
 * @function fetchCategoryById
 * @param {string} id - Category UUID
 * @returns {Promise<CategoryWithChildren>} Category with children and product count
 *
 * @example
 * // Fetch category for editing
 * dispatch(fetchCategoryById('category-uuid'));
 *
 * @see categoryApi.getCategoryById for backend API call
 */
export const fetchCategoryById = createAsyncThunk(
  'categories/fetchCategoryById',
  async (id: string) => {
    return await categoryApi.getCategoryById(id);
  }
);

/**
 * Async thunk: Create new category
 *
 * Creates a new category. Category number is auto-generated by backend
 * (CAT-XXXXXX format). Categories can be created at root level or as
 * children of existing categories.
 *
 * After successful creation, fetchCategories should be dispatched to
 * refresh the tree with the new category.
 *
 * @async
 * @function createCategory
 * @param {CreateCategoryRequest} data - Category data (name, parent_category_id, etc.)
 * @returns {Promise<CategoryWithChildren>} Created category with generated category_number
 *
 * @example
 * // Create root category
 * const result = await dispatch(createCategory({
 *   name: 'Electronics',
 *   description: 'Electronic products'
 * }));
 * if (createCategory.fulfilled.match(result)) {
 *   dispatch(fetchCategories()); // Refresh tree
 * }
 *
 * @example
 * // Create subcategory
 * dispatch(createCategory({
 *   name: 'Smartphones',
 *   parent_category_id: 'electronics-uuid',
 *   display_order: 1
 * }));
 *
 * @see categoryApi.createCategory for backend API call
 * @see CreateCategoryRequest interface in types/category.types.ts
 */
export const createCategory = createAsyncThunk(
  'categories/createCategory',
  async (data: CreateCategoryRequest) => {
    return await categoryApi.createCategory(data);
  }
);

/**
 * Async thunk: Update existing category
 *
 * Updates category with partial field updates. Only provided fields are changed.
 * Can update name, description, parent_category_id, display_order, or is_active.
 *
 * After successful update, fetchCategories should be dispatched to refresh
 * the tree with updated values.
 *
 * @async
 * @function updateCategory
 * @param {object} params - Update parameters
 * @param {string} params.id - Category UUID to update
 * @param {UpdateCategoryRequest} params.data - Fields to update (partial)
 * @returns {Promise<CategoryWithChildren>} Updated category
 *
 * @example
 * // Update category name
 * const result = await dispatch(updateCategory({
 *   id: 'category-uuid',
 *   data: { name: 'New Category Name' }
 * }));
 * if (updateCategory.fulfilled.match(result)) {
 *   dispatch(fetchCategories()); // Refresh tree
 * }
 *
 * @example
 * // Move category to different parent
 * dispatch(updateCategory({
 *   id: 'category-uuid',
 *   data: { parent_category_id: 'new-parent-uuid' }
 * }));
 *
 * @see categoryApi.updateCategory for backend API call
 * @see UpdateCategoryRequest interface in types/category.types.ts
 */
export const updateCategory = createAsyncThunk(
  'categories/updateCategory',
  async ({ id, data }: { id: string; data: UpdateCategoryRequest }) => {
    return await categoryApi.updateCategory(id, data);
  }
);

/**
 * Async thunk: Delete category (soft delete)
 *
 * Soft deletes category by setting is_active=false. The backend validates
 * that the category has no active products and no active child categories
 * before allowing deletion.
 *
 * After successful deletion, the category is removed from the tree structure
 * in Redux state (recursively searching through children).
 *
 * Validation rules:
 * - Cannot delete category with active products
 * - Cannot delete category with active child categories
 * - Category remains in database but hidden (soft delete)
 *
 * @async
 * @function deleteCategory
 * @param {string} id - Category UUID to delete
 * @returns {Promise<string>} Deleted category ID
 * @throws {Error} If category has active products or children
 *
 * @example
 * // Delete category
 * try {
 *   await dispatch(deleteCategory('category-uuid'));
 *   // Category removed from tree
 * } catch (error) {
 *   // Handle validation error (has products/children)
 * }
 *
 * @see categoryApi.deleteCategory for backend API call
 */
export const deleteCategory = createAsyncThunk(
  'categories/deleteCategory',
  async (id: string) => {
    await categoryApi.deleteCategory(id);
    return id;
  }
);

/**
 * Categories Redux Slice
 *
 * Manages category tree state with 2 synchronous reducers and 5 async thunks:
 * - clearSelectedCategory: Clear selected category
 * - clearError: Clear error message
 * - fetchCategories: Fetch category tree (async)
 * - fetchCategoryById: Fetch category details (async)
 * - createCategory: Create new category (async)
 * - updateCategory: Update category (async)
 * - deleteCategory: Delete category (async)
 *
 * @slice categories
 * @state CategoriesState
 */
const categoriesSlice = createSlice({
  name: 'categories',
  initialState,
  reducers: {
    /**
     * Clears selected category
     *
     * Resets selectedCategory to null when closing edit modal.
     *
     * @param {CategoriesState} state - Current categories state
     *
     * @example
     * // Close category edit modal
     * dispatch(clearSelectedCategory());
     */
    clearSelectedCategory: (state) => {
      state.selectedCategory = null;
    },

    /**
     * Clears error message
     *
     * Resets error state after displaying error to user or before retrying.
     *
     * @param {CategoriesState} state - Current categories state
     *
     * @example
     * // Clear error before retry
     * dispatch(clearError());
     */
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // FetchCategories: pending - set loading state
      .addCase(fetchCategories.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      // FetchCategories: fulfilled - store category tree
      .addCase(fetchCategories.fulfilled, (state, action) => {
        state.loading = false;
        state.categories = action.payload;
      })
      // FetchCategories: rejected - set error state
      .addCase(fetchCategories.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to fetch categories';
      })
      // FetchCategoryById: fulfilled - store selected category
      .addCase(fetchCategoryById.fulfilled, (state, action) => {
        state.selectedCategory = action.payload;
      })
      // CreateCategory: fulfilled - clear error (tree refresh handled by component)
      .addCase(createCategory.fulfilled, (state) => {
        // Component should dispatch fetchCategories() to refresh tree
        state.error = null;
      })
      // UpdateCategory: fulfilled - clear error (tree refresh handled by component)
      .addCase(updateCategory.fulfilled, (state) => {
        // Component should dispatch fetchCategories() to refresh tree
        state.error = null;
      })
      // DeleteCategory: fulfilled - remove from tree recursively
      .addCase(deleteCategory.fulfilled, (state, action) => {
        /**
         * Recursively removes category from tree structure
         *
         * Searches through all categories and their children to find and
         * remove the deleted category. This maintains tree structure integrity.
         *
         * @param {CategoryWithChildren[]} categories - Array of categories to search
         * @param {string} id - Category ID to remove
         * @returns {CategoryWithChildren[]} Filtered categories with deleted category removed
         */
        const removeCategory = (categories: CategoryWithChildren[], id: string): CategoryWithChildren[] => {
          return categories
            .filter((cat) => cat.id !== id) // Remove if this is the deleted category
            .map((cat) => ({
              ...cat,
              children: removeCategory(cat.children, id), // Recursively remove from children
            }));
        };

        // Remove deleted category from tree
        state.categories = removeCategory(state.categories, action.payload);
      });
  },
});

export const { clearSelectedCategory, clearError } = categoriesSlice.actions;
export default categoriesSlice.reducer;
